---
eip: 7688
title: Forward compatible consensus data structures
description: Transition consensus SSZ data structures to StableContainer
author: Etan Kissling (@etan-status), Cayman (@wemeetagain)
discussions-to: https://ethereum-magicians.org/t/eip-7688-forward-compatible-consensus-data-structures/19673
status: Review
type: Standards Track
category: Core
created: 2024-04-15
requires: 6110, 7002, 7251, 7495, 7549, 7569
---

## Abstract

This EIP defines the changes needed to adopt `StableContainer` from [EIP-7495](./eip-7495.md) in consensus data structures.

## Motivation

Ethereum's consensus data structures make heavy use of [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md) `Container`, which defines how they are serialized and merkleized. The merkleization scheme allows application implementations to verify that individual fields (and partial fields) have not been tampered with. This is useful, for example, in smart contracts of decentralized staking pools that wish to verify that participating validators have not been slashed.

While SSZ `Container` defines how data structures are merkleized, the merkleization is prone to change across the different forks. When that happens, e.g., because new features are added or old features get removed, existing verifier implementations need to be updated to be able to continue processing proofs.

`StableContainer`, of [EIP-7495](./eip-7495.md), is a forward compatible alternative that guarantees a forward compatible merkleization scheme. By transitioning consensus data structures to use `StableContainer`, smart contracts that contain verifier logic no longer have to be maintained in lockstep with Ethereum's fork schedule as long as the underlying features that they verify don't change. For example, as long as the concept of slashing is represented using the boolean `slashed` field, existing verifiers will not break when unrelated features get added or removed. This is also true for off-chain verifiers, e.g., in hardware wallets or in operating systems for mobile devices that are on a different software update cadence than Ethereum.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Conversion procedure

For each converted data structure, a new fork agnostic `StableContainer` type `B` is introduced that serves as the primary definition of each data structure.

- Each `StableContainer` is assigned a capacity to represent its potential design space that SHALL NOT change across future forks; if it is later determined that it is insufficient, a new field can be added to contain additional fields in a sub-container.
- The `StableContainer` starts as a copy of the latest fork's `Container` equivalent, except that all field types `T` are wrapped into `Optional[T]`.
- To guarantee forward and backward compatibility, new fields from future forks MUST only be appended to the `StableContainer` definition.
- The type of existing fields MUST NOT change, including the capacity of `List`/`Bitlist`. If a change is necessary, the old field SHALL NOT be used anymore and a new field with a new name SHALL be considered. It is important to anticipate potential future extensions when deciding on the capacities of the `StableContainer` itself and of the various lists.
- For `List`/`Bitlist`, the opportunity SHOULD be used to re-evaluate their design space capacity. If the design space is increased, application logic SHALL check the fork specific length limit; the SSZ library solely defines the merkleization limit, not the serialization limit.
- The conversion process is repeated for each field type. All field types referred to by the `StableContainer` MUST be `StableContainer` themselves, or are considered immutable.

Subsequently, for each `StableContainer` base type `B`, a fork specific `Profile[B]` type is introduced that matches the latest fork's `Container` equivalent. The old `Container` is no longer necessary. The SSZ serialization of `Profile` is compatible with `Container`, but the merkleization and `hash_tree_root` are computed differently. Furthermore, `Profile` MAY use fields of `Optional` type if necessary.

Subsequent forks specify a new `Profile`.

- If new fields of type `T` are added, they are appended to the `StableContainer` as `Optional[T]` to register them with the stable merkleization scheme. In the new fork's `Profile`, the new field MAY be `T` (required), or `Optional[T]` (optional).
- If old fields are deprecated, they are kept in the `StableContainer` to retain the stable merkleization scheme. In the new fork's `Profile`, the field is omitted from the definition. The SSZ library guarantees that `hash_tree_root` and all generalized indices remain the same.
- Other fields MAY be changed between `T` (required) and `Optional[T]` (optional) in the new fork's `Profile`. No changes to the `StableContainer` are required for such changes.

### Immutable types

These types are used as part of the `StableContainer` definitions, and, as they are not `StableContainer` themselves, are considered to have immutable Merkleization. If a future fork requires changing these types in an incompatible way, a new type SHALL be defined and assigned a new field name.

| Type | Description |
| - | - |
| [`Slot`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Slot number on the beacon chain |
| [`Epoch`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Epoch number on the beacon chain, a group of slots |
| [`CommitteeIndex`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Index of a committee within a slot |
| [`ValidatorIndex`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Unique index of a beacon chain validator |
| [`Gwei`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Amount in Gwei (1 ETH = 10^9 Gwei = 10^18 Wei) |
| [`Root`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Byte vector containing an SSZ Merkle root |
| [`Hash32`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Byte vector containing an opaque 32-byte hash |
| [`Version`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Consensus fork version number |
| [`BLSPubkey`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Cryptographic type representing a BLS12-381 public key |
| [`BLSSignature`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#custom-types) | Cryptographic type representing a BLS12-381 signature |
| [`KZGCommitment`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/_features/sharding/polynomial-commitments.md#custom-types) | G1 curve point for the KZG polynomial commitment scheme |
| [`Fork`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#fork) | Consensus fork information |
| [`Checkpoint`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#checkpoint) | Tuple referring to the most recent beacon block up through an epoch's start slot |
| [`Validator`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#validator) | Information about a beacon chain validator |
| [`AttestationData`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#attestationdata) | Vote that attests to the availability and validity of a particular consensus block |
| [`Eth1Data`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#eth1data) | Target tracker for importing deposits from transaction logs |
| [`DepositData`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#depositdata) | Log data emitted as part of a transaction's receipt when depositing to the beacon chain |
| [`BeaconBlockHeader`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#beaconblockheader) | Consensus block header |
| [`ProposerSlashing`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#proposerslashing) | Tuple of two equivocating consensus block headers |
| [`Deposit`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#deposit) | Tuple of deposit data and its inclusion proof |
| [`VoluntaryExit`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#voluntaryexit) | Consensus originated request to exit a validator from the beacon chain |
| [`SignedVoluntaryExit`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/phase0/beacon-chain.md#signedvoluntaryexit) | Tuple of voluntary exit request and its signature |
| [`SyncAggregate`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/altair/beacon-chain.md#syncaggregate) | Cryptographic type representing an aggregate sync committee signature |
| [`ExecutionAddress`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/bellatrix/beacon-chain.md#custom-types) | Byte vector containing an account address on the execution layer |
| [`Transaction`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/bellatrix/beacon-chain.md#custom-types) | Byte list containing an RLP encoded transaction |
| [`WithdrawalIndex`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/capella/beacon-chain.md#custom-types) | Unique index of a withdrawal from any validator's balance to the execution layer |
| [`Withdrawal`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/capella/beacon-chain.md#withdrawal) | Withdrawal from a beacon chain validator's balance to the execution layer |
| [`DepositRequest`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/electra/beacon-chain.md#depositrequest) | Tuple of flattened deposit data and its sequential index |
| [`WithdrawalRequest`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/electra/beacon-chain.md#withdrawalrequest) | Execution originated request to withdraw from a validator to the execution layer |
| [`ConsolidationRequest`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/electra/beacon-chain.md#consolidation) | Execution originated request to consolidate two beacon chain validators |
| [`BLSToExecutionChange`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/capella/beacon-chain.md#blstoexecutionchange) | Request to register the withdrawal account address of a beacon chain validator |
| [`SignedBLSToExecutionChange`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/capella/beacon-chain.md#signedblstoexecutionchange) | Tuple of withdrawal account address registration request and its signature |
| [`ParticipationFlags`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/altair/beacon-chain.md#custom-types) | Participation tracker of a beacon chain validator within an epoch |
| [`HistoricalSummary`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/capella/beacon-chain.md#historicalsummary) | Tuple combining a historical block root and historical state root |
| [`PendingBalanceDeposit`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/electra/beacon-chain.md#pendingbalancedeposit) | Pending operation for depositing to a beacon chain validator |
| [`PendingPartialWithdrawal`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/electra/beacon-chain.md#pendingpartialwithdrawal) | Pending operation for withdrawing from a beacon chain validator |
| [`PendingConsolidation`](https://github.com/ethereum/consensus-specs/blob/389b2ddfb954731da7ccf4c0ef89fab2d4575b99/specs/electra/beacon-chain.md#pendingconsolidation) | Pending operation for consolidating two beacon chain validators |

### `StableContainer` capacities

| Name | Value | Description |
| - | - | - |
| `MAX_ATTESTATION_FIELDS` | `uint64(2**3)` (= 8) | Maximum number of fields to which `StableAttestation` can ever grow in the future |
| `MAX_INDEXED_ATTESTATION_FIELDS` | `uint64(2**3)` (= 8) | Maximum number of fields to which `StableIndexedAttestation` can ever grow in the future |
| `MAX_EXECUTION_PAYLOAD_FIELDS` | `uint64(2**6)` (= 64) | Maximum number of fields to which `StableExecutionPayload` can ever grow in the future |
| `MAX_EXECUTION_REQUESTS_FIELDS` | `uint64(2**4)` (= 16) | Maximum number of fields to which `StableExecutionRequests` can ever grow in the future |
| `MAX_BEACON_BLOCK_BODY_FIELDS` | `uint64(2**6)` (= 64) | Maximum number of fields to which `StableBeaconBlockBody` can ever grow in the future |
| `MAX_BEACON_STATE_FIELDS` | `uint64(2**7)` (= 128) | Maximum number of fields to which `StableBeaconState` can ever grow in the future |

Maximum proof depth:

- `StableBeaconState` > `validators` (1 + 7) > `<item>` (1 + 40) > `pubkey` (3) > `<chunk>` (1) = 53 bits
- `StableBeaconBlockBody` > `execution_payload` (1 + 6) > `transactions` (1 + 6) > `<item>` (1 + 20) > `<chunk>` (1 + 25) = 61 bits

### Fork-agnostic `StableContainer` definitions

These type definitions are fork independent and shared across all forks. They are not exchanged over libp2p.

```python
class StableAttestation(StableContainer[MAX_ATTESTATION_FIELDS]):
    aggregation_bits: Optional[Bitlist[MAX_VALIDATORS_PER_COMMITTEE * MAX_COMMITTEES_PER_SLOT]]
    data: Optional[AttestationData]
    signature: Optional[BLSSignature]
    committee_bits: Optional[Bitvector[MAX_COMMITTEES_PER_SLOT]]

class StableIndexedAttestation(StableContainer[MAX_INDEXED_ATTESTATION_FIELDS]):
    attesting_indices: Optional[List[ValidatorIndex, MAX_VALIDATORS_PER_COMMITTEE * MAX_COMMITTEES_PER_SLOT]]
    data: Optional[AttestationData]
    signature: Optional[BLSSignature]

class StableAttesterSlashing(Container):
    attestation_1: StableIndexedAttestation
    attestation_2: StableIndexedAttestation

class StableExecutionPayload(StableContainer[MAX_EXECUTION_PAYLOAD_FIELDS]):
    parent_hash: Optional[Hash32]
    fee_recipient: Optional[ExecutionAddress]  # 'beneficiary' in the yellow paper
    state_root: Optional[Bytes32]
    receipts_root: Optional[Bytes32]
    logs_bloom: Optional[ByteVector[BYTES_PER_LOGS_BLOOM]]
    prev_randao: Optional[Bytes32]  # 'difficulty' in the yellow paper
    block_number: Optional[uint64]  # 'number' in the yellow paper
    gas_limit: Optional[uint64]
    gas_used: Optional[uint64]
    timestamp: Optional[uint64]
    extra_data: Optional[ByteList[MAX_EXTRA_DATA_BYTES]]
    base_fee_per_gas: Optional[uint256]
    block_hash: Optional[Hash32]  # Hash of execution block
    transactions: Optional[List[Transaction, MAX_TRANSACTIONS_PER_PAYLOAD]]
    withdrawals: Optional[List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]]  # [New in Capella]
    blob_gas_used: Optional[uint64]  # [New in Deneb:EIP4844]
    excess_blob_gas: Optional[uint64]  # [New in Deneb:EIP4844]

class StableExecutionPayloadHeader(StableContainer[MAX_EXECUTION_PAYLOAD_FIELDS]):
    parent_hash: Optional[Hash32]
    fee_recipient: Optional[ExecutionAddress]
    state_root: Optional[Bytes32]
    receipts_root: Optional[Bytes32]
    logs_bloom: Optional[ByteVector[BYTES_PER_LOGS_BLOOM]]
    prev_randao: Optional[Bytes32]
    block_number: Optional[uint64]
    gas_limit: Optional[uint64]
    gas_used: Optional[uint64]
    timestamp: Optional[uint64]
    extra_data: Optional[ByteList[MAX_EXTRA_DATA_BYTES]]
    base_fee_per_gas: Optional[uint256]
    block_hash: Optional[Hash32]  # Hash of execution block
    transactions_root: Optional[Root]
    withdrawals_root: Optional[Root]  # [New in Capella]
    blob_gas_used: Optional[uint64]  # [New in Deneb:EIP4844]
    excess_blob_gas: Optional[uint64]  # [New in Deneb:EIP4844]

class StableExecutionRequests(StableContainer[MAX_EXECUTION_REQUESTS_FIELDS]):
    deposits: Optional[List[DepositRequest, MAX_DEPOSIT_REQUESTS_PER_PAYLOAD]]  # [New in Electra:EIP6110]
    withdrawals: Optional[List[WithdrawalRequest, MAX_WITHDRAWAL_REQUESTS_PER_PAYLOAD]]  # [New in Electra:EIP7002:EIP7251]
    consolidations: Optional[List[ConsolidationRequest, MAX_CONSOLIDATION_REQUESTS_PER_PAYLOAD]]  # [New in Electra:EIP7251]

class StableBeaconBlockBody(StableContainer[MAX_BEACON_BLOCK_BODY_FIELDS]):
    randao_reveal: Optional[BLSSignature]
    eth1_data: Optional[Eth1Data]  # Eth1 data vote
    graffiti: Optional[Bytes32]  # Arbitrary data
    proposer_slashings: Optional[List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]]
    attester_slashings: Optional[List[StableAttesterSlashing, MAX_ATTESTER_SLASHINGS_ELECTRA]]  # [Modified in Electra:EIP7549]
    attestations: Optional[List[StableAttestation, MAX_ATTESTATIONS_ELECTRA]]  # [Modified in Electra:EIP7549]
    deposits: Optional[List[Deposit, MAX_DEPOSITS]]
    voluntary_exits: Optional[List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]]
    sync_aggregate: Optional[SyncAggregate]  # [New in Altair]
    execution_payload: Optional[StableExecutionPayload]  # [New in Bellatrix]
    bls_to_execution_changes: Optional[List[SignedBLSToExecutionChange, MAX_BLS_TO_EXECUTION_CHANGES]]  # [New in Capella]
    blob_kzg_commitments: Optional[List[KZGCommitment, MAX_BLOB_COMMITMENTS_PER_BLOCK]]  # [New in Deneb:EIP4844]
    execution_requests: Optional[StableExecutionRequests]  # [New in Electra]

class StableBeaconState(StableContainer[MAX_BEACON_STATE_FIELDS]):
    # Versioning
    genesis_time: Optional[uint64]
    genesis_validators_root: Optional[Root]
    slot: Optional[Slot]
    fork: Optional[Fork]
    # History
    latest_block_header: Optional[BeaconBlockHeader]
    block_roots: Optional[Vector[Root, SLOTS_PER_HISTORICAL_ROOT]]
    state_roots: Optional[Vector[Root, SLOTS_PER_HISTORICAL_ROOT]]
    historical_roots: Optional[List[Root, HISTORICAL_ROOTS_LIMIT]]  # Frozen in Capella, replaced by historical_summaries
    # Eth1
    eth1_data: Optional[Eth1Data]
    eth1_data_votes: Optional[List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]]
    eth1_deposit_index: Optional[uint64]
    # Registry
    validators: Optional[List[Validator, VALIDATOR_REGISTRY_LIMIT]]
    balances: Optional[List[Gwei, VALIDATOR_REGISTRY_LIMIT]]
    # Randomness
    randao_mixes: Optional[Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]]
    # Slashings
    slashings: Optional[Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]]  # Per-epoch sums of slashed effective balances
    # Participation
    previous_epoch_participation: Optional[List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]]  # [Modified in Altair]
    current_epoch_participation: Optional[List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]]  # [Modified in Altair]
    # Finality
    justification_bits: Optional[Bitvector[JUSTIFICATION_BITS_LENGTH]]  # Bit set for every recent justified epoch
    previous_justified_checkpoint: Optional[Checkpoint]
    current_justified_checkpoint: Optional[Checkpoint]
    finalized_checkpoint: Optional[Checkpoint]
    # Inactivity
    inactivity_scores: Optional[List[uint64, VALIDATOR_REGISTRY_LIMIT]]  # [New in Altair]
    # Sync
    current_sync_committee: Optional[SyncCommittee]  # [New in Altair]
    next_sync_committee: Optional[SyncCommittee]  # [New in Altair]
    # Execution
    latest_execution_payload_header: Optional[StableExecutionPayloadHeader]  # [New in Bellatrix]
    # Withdrawals
    next_withdrawal_index: Optional[WithdrawalIndex]  # [New in Capella]
    next_withdrawal_validator_index: Optional[ValidatorIndex]  # [New in Capella]
    # Deep history valid from Capella onwards
    historical_summaries: Optional[List[HistoricalSummary, HISTORICAL_ROOTS_LIMIT]]  # [New in Capella]
    deposit_requests_start_index: Optional[uint64]  # [New in Electra:EIP6110]
    deposit_balance_to_consume: Optional[Gwei]  # [New in Electra:EIP7251]
    exit_balance_to_consume: Optional[Gwei]  # [New in Electra:EIP7251]
    earliest_exit_epoch: Optional[Epoch]  # [New in Electra:EIP7251]
    consolidation_balance_to_consume: Optional[Gwei]  # [New in Electra:EIP7251]
    earliest_consolidation_epoch: Optional[Epoch]  # [New in Electra:EIP7251]
    pending_balance_deposits: Optional[List[PendingBalanceDeposit, PENDING_BALANCE_DEPOSITS_LIMIT]]  # [New in Electra:EIP7251]
    # [New in Electra:EIP7251]
    pending_partial_withdrawals: Optional[List[PendingPartialWithdrawal, PENDING_PARTIAL_WITHDRAWALS_LIMIT]]
    pending_consolidations: Optional[List[PendingConsolidation, PENDING_CONSOLIDATIONS_LIMIT]]  # [New in Electra:EIP7251]
```

### Fork-specific `Profile` definitions

The consensus type definitions specific to the fork that introduces this EIP are updated to inherit the Merkleization of the `StableContainer` definitions. Fields are kept as is.

```python
class Attestation(Profile[StableAttestation]):
    ...

class IndexedAttestation(Profile[StableIndexedAttestation]):
    ...

class ExecutionPayload(Profile[StableExecutionPayload]):
    ...

class ExecutionPayloadHeader(Profile[StableExecutionPayloadHeader]):
    ...

class ExecutionRequests(Profile[StableExecutionRequests]):
    ...

class BeaconBlockBody(Profile[StableBeaconBlockBody]):
    ...

class BeaconState(Profile[StableBeaconState]):
    ...
```

### Additional consensus spec changes

Due to changing the merkle tree depth of `BeaconState` and `BeaconBlockBody`, several `_GINDEX` and `_PROOF_DEPTH` constants need to be redefined.

Changes come from two sources, Altair light client proofs and Deneb kzg commitment inclusion proofs.

#### Altair

##### Constants

*[New in EIP7688]*

| Name | Value |
| - | - |
| `FINALIZED_ROOT_GINDEX_STABLE` | `get_generalized_index(StableBeaconState, 'finalized_checkpoint', 'root')` (= 210) |
| `CURRENT_SYNC_COMMITTEE_GINDEX_STABLE` | `get_generalized_index(StableBeaconState, 'current_sync_committee')` (= 108) |
| `NEXT_SYNC_COMMITTEE_GINDEX_STABLE` | `get_generalized_index(StableBeaconState, 'next_sync_committee')` (= 110) |

##### Redefined types

| Name | SSZ equivalent | Description |
| - | - | - |
| `FinalityBranch` | `Vector[Bytes32, floorlog2(FINALIZED_ROOT_GINDEX_STABLE)]` | Merkle branch of `finalized_checkpoint.root` within `BeaconState` |
| `CurrentSyncCommitteeBranch` | `Vector[Bytes32, floorlog2(CURRENT_SYNC_COMMITTEE_GINDEX_STABLE)]` | Merkle branch of `current_sync_committee` within `BeaconState` |
| `NextSyncCommitteeBranch` | `Vector[Bytes32, floorlog2(NEXT_SYNC_COMMITTEE_GINDEX_STABLE)]` | Merkle branch of `next_sync_committee` within `BeaconState` |

##### Redefined containers

###### `LightClientBootstrap`

```python
class LightClientBootstrap(Container):
    # Header matching the requested beacon block root
    header: LightClientHeader
    # Current sync committee corresponding to `header.beacon.state_root`
    current_sync_committee: SyncCommittee
    current_sync_committee_branch: CurrentSyncCommitteeBranch # changed in EIP-7688
```

###### `LightClientUpdate`

```python
class LightClientUpdate(Container):
    # Header attested to by the sync committee
    attested_header: LightClientHeader
    # Next sync committee corresponding to `attested_header.beacon.state_root`
    next_sync_committee: SyncCommittee
    next_sync_committee_branch: NextSyncCommitteeBranch # changed in EIP-7688
    # Finalized header corresponding to `attested_header.beacon.state_root`
    finalized_header: LightClientHeader
    finality_branch: FinalityBranch # changed in EIP-7688
    # Sync committee aggregate signature
    sync_aggregate: SyncAggregate
    # Slot at which the aggregate signature was created (untrusted)
    signature_slot: Slot
```

###### `LightClientFinalityUpdate`

```python
class LightClientFinalityUpdate(Container):
    # Header attested to by the sync committee
    attested_header: LightClientHeader
    # Finalized header corresponding to `attested_header.beacon.state_root`
    finalized_header: LightClientHeader
    finality_branch: FinalityBranch # changed in EIP-7688
    # Sync committee aggregate signature
    sync_aggregate: SyncAggregate
    # Slot at which the aggregate signature was created (untrusted)
    signature_slot: Slot
```

###### `LightClientOptimisticUpdate`

```python
class LightClientOptimisticUpdate(Container):
    # Header attested to by the sync committee
    attested_header: LightClientHeader
    # Sync committee aggregate signature
    sync_aggregate: SyncAggregate # changed in EIP-7688
    # Slot at which the aggregate signature was created (untrusted)
    signature_slot: Slot
```

##### Redefined functions


###### `initialize_light_client_store`

```python
def initialize_light_client_store(trusted_block_root: Root,
                                  bootstrap: LightClientBootstrap) -> LightClientStore:
    assert is_valid_light_client_header(bootstrap.header)
    assert hash_tree_root(bootstrap.header.beacon) == trusted_block_root

    assert is_valid_merkle_branch(
        leaf=hash_tree_root(bootstrap.current_sync_committee),
        branch=bootstrap.current_sync_committee_branch,
        depth=floorlog2(CURRENT_SYNC_COMMITTEE_GINDEX_STABLE), # changed in EIP-7688
        index=get_subtree_index(CURRENT_SYNC_COMMITTEE_GINDEX_STABLE), # changed in EIP-7688
        root=bootstrap.header.beacon.state_root,
    )

    return LightClientStore(
        finalized_header=bootstrap.header,
        current_sync_committee=bootstrap.current_sync_committee,
        next_sync_committee=SyncCommittee(),
        best_valid_update=None,
        optimistic_header=bootstrap.header,
        previous_max_active_participants=0,
        current_max_active_participants=0,
    )
```

### `validate_light_client_update`

```python
def validate_light_client_update(store: LightClientStore,
                                 update: LightClientUpdate,
                                 current_slot: Slot,
                                 genesis_validators_root: Root) -> None:
    # Verify sync committee has sufficient participants
    sync_aggregate = update.sync_aggregate
    assert sum(sync_aggregate.sync_committee_bits) >= MIN_SYNC_COMMITTEE_PARTICIPANTS

    # Verify update does not skip a sync committee period
    assert is_valid_light_client_header(update.attested_header)
    update_attested_slot = update.attested_header.beacon.slot
    update_finalized_slot = update.finalized_header.beacon.slot
    assert current_slot >= update.signature_slot > update_attested_slot >= update_finalized_slot
    store_period = compute_sync_committee_period_at_slot(store.finalized_header.beacon.slot)
    update_signature_period = compute_sync_committee_period_at_slot(update.signature_slot)
    if is_next_sync_committee_known(store):
        assert update_signature_period in (store_period, store_period + 1)
    else:
        assert update_signature_period == store_period

    # Verify update is relevant
    update_attested_period = compute_sync_committee_period_at_slot(update_attested_slot)
    update_has_next_sync_committee = not is_next_sync_committee_known(store) and (
        is_sync_committee_update(update) and update_attested_period == store_period
    )
    assert (
        update_attested_slot > store.finalized_header.beacon.slot
        or update_has_next_sync_committee
    )

    # Verify that the `finality_branch`, if present, confirms `finalized_header`
    # to match the finalized checkpoint root saved in the state of `attested_header`.
    # Note that the genesis finalized checkpoint root is represented as a zero hash.
    if not is_finality_update(update):
        assert update.finalized_header == LightClientHeader()
    else:
        if update_finalized_slot == GENESIS_SLOT:
            assert update.finalized_header == LightClientHeader()
            finalized_root = Bytes32()
        else:
            assert is_valid_light_client_header(update.finalized_header)
            finalized_root = hash_tree_root(update.finalized_header.beacon)
        assert is_valid_merkle_branch(
            leaf=finalized_root,
            branch=update.finality_branch,
            depth=floorlog2(FINALIZED_ROOT_GINDEX_STABLE), # changed in EIP-7688
            index=get_subtree_index(FINALIZED_ROOT_GINDEX_STABLE), # changed in EIP-7688
            root=update.attested_header.beacon.state_root,
        )

    # Verify that the `next_sync_committee`, if present, actually is the next sync committee saved in the
    # state of the `attested_header`
    if not is_sync_committee_update(update):
        assert update.next_sync_committee == SyncCommittee()
    else:
        if update_attested_period == store_period and is_next_sync_committee_known(store):
            assert update.next_sync_committee == store.next_sync_committee
        assert is_valid_merkle_branch(
            leaf=hash_tree_root(update.next_sync_committee),
            branch=update.next_sync_committee_branch,
            depth=floorlog2(NEXT_SYNC_COMMITTEE_GINDEX_STABLE), # changed in EIP-7688
            index=get_subtree_index(NEXT_SYNC_COMMITTEE_GINDEX_STABLE), # changed in EIP-7688
            root=update.attested_header.beacon.state_root,
        )

    # Verify sync committee aggregate signature
    if update_signature_period == store_period:
        sync_committee = store.current_sync_committee
    else:
        sync_committee = store.next_sync_committee
    participant_pubkeys = [
        pubkey for (bit, pubkey) in zip(sync_aggregate.sync_committee_bits, sync_committee.pubkeys)
        if bit
    ]
    fork_version_slot = max(update.signature_slot, Slot(1)) - Slot(1)
    fork_version = compute_fork_version(compute_epoch_at_slot(fork_version_slot))
    domain = compute_domain(DOMAIN_SYNC_COMMITTEE, fork_version, genesis_validators_root)
    signing_root = compute_signing_root(update.attested_header.beacon, domain)
    assert bls.FastAggregateVerify(participant_pubkeys, signing_root, sync_aggregate.sync_committee_signature)
```

#### Deneb

##### Preset

*[New in EIP7688]*

| Name                                     | Value                             | Description                                                         |
|------------------------------------------|-----------------------------------|---------------------------------------------------------------------|
| `KZG_COMMITMENT_INCLUSION_PROOF_DEPTH_STABLE`   | `uint64(floorlog2(get_generalized_index(StableBeaconBlockBody, 'blob_kzg_commitments')) + 1 + ceillog2(MAX_BLOB_COMMITMENTS_PER_BLOCK))` (= 18) | <!-- predefined --> Merkle proof depth for `blob_kzg_commitments` list item |


##### Redefined Containers

###### `BlobSidecar`

*[Changed in EIP-7688]*

```python
class BlobSidecar(Container):
    index: BlobIndex  # Index of blob in block
    blob: Blob
    kzg_commitment: KZGCommitment
    kzg_proof: KZGProof  # Allows for quick verification of kzg_commitment
    signed_block_header: SignedBeaconBlockHeader
    kzg_commitment_inclusion_proof: Vector[Bytes32, KZG_COMMITMENT_INCLUSION_PROOF_DEPTH_STABLE] # changed in EIP-7688
```

##### Redefined functions

###### `verify_blob_sidecar_inclusion_proof`

```python
def verify_blob_sidecar_inclusion_proof(blob_sidecar: BlobSidecar) -> bool:
    gindex = get_subtree_index(get_generalized_index(BeaconBlockBody, 'blob_kzg_commitments', blob_sidecar.index))
    return is_valid_merkle_branch(
        leaf=blob_sidecar.kzg_commitment.hash_tree_root(),
        branch=blob_sidecar.kzg_commitment_inclusion_proof,
        depth=KZG_COMMITMENT_INCLUSION_PROOF_DEPTH_STABLE, # changed in EIP-7688
        index=gindex,
        root=blob_sidecar.signed_block_header.message.body_root,
    )
```

## Rationale

### Best timing?

Applying this EIP breaks `hash_tree_root` and Merkle tree verifiers a single time, while promising forward compatibility from the fork going forward. It is best to apply it before merkleization would be broken by different changes. Merkleization is broken by a `Container` reaching a new power of 2 in its number of fields.

### Can this be applied retroactively?

While `Profile` serializes in the same way as the legacy `Container`, the merkleization and `hash_tree_root` of affected data structures changes. Therefore, verifiers that wish to process Merkle proofs of legacy variants still need to support the corresponding legacy schemes.

### Immutability

Once a field in a `StableContainer` has been published, its name can no longer be used to represent a different type in the future. This includes list types with a higher capacity than originally intended. This is in line with historical management of certain cases:

- Phase0: `BeaconState` contained `previous_epoch_attestations` / `current_epoch_attestations`
- Altair: `BeaconState` replaced these fields with `previous_epoch_participation` / `current_epoch_participation`

Furthermore, new fields have to be appended at the end of `StableContainer`. This is in line with historical management of other cases:

- Capella appended `historical_summaries` to `BeaconState` instead of squeezing the new field next to `historical_roots`

With `StableContainer`, stable Merkleization requires these rules to become strict.

## Backwards Compatibility

Existing Merkle proof verifiers need to be updated to support the new Merkle tree shape. This includes verifiers in smart contracts on different blockchains and verifiers in hardware wallets, if applicable.

Note that backwards compatibility is also broken when one of the converted `Container` data structures would reach a new power of 2 in its number of fields.

## Security Considerations

None

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
